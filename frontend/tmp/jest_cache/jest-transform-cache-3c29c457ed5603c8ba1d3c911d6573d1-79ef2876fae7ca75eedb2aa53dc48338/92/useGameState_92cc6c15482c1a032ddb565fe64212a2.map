{"file":"/Users/sayantanpal100/Desktop/Mumu--onchain-puzzle-game/frontend/src/hooks/useGameState.ts","mappings":"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","names":[],"sources":["/Users/sayantanpal100/Desktop/Mumu--onchain-puzzle-game/frontend/src/hooks/useGameState.ts"],"sourcesContent":["// src/hooks/useGameState.ts\nimport { useState, useCallback } from 'react';\nimport { MatterType, GridPosition, Formula, GameState } from '../types/GameTypes';\nimport { evaluateFormula } from '../utils/formulaUtils';\nimport { getAdjacentCells } from '../utils/gridUtils';\n\nexport const useGameState = (initialGrid: MatterType[][], targetGrid?: MatterType[][]) => {\n  const [gameState, setGameState] = useState<GameState>({\n    grid: initialGrid.map(row => [...row]), // Deep copy\n    history: [initialGrid.map(row => [...row])], // Save initial state in history\n    moves: 0\n  });\n  \n  const setGrid = useCallback((newGrid: MatterType[][]) => {\n    setGameState(prevState => ({\n      ...prevState,\n      grid: newGrid,\n      history: [...prevState.history, newGrid],\n      moves: prevState.moves + 1\n    }));\n  }, []);\n  \n  const applyMatterTransformation = useCallback((position: GridPosition, formula: Formula | null) => {\n    const { row, col } = position;\n    const { grid } = gameState;\n    \n    // If the cell is empty (VOID), do nothing\n    if (grid[row][col] === MatterType.VOID) return;\n    \n    const newGrid = grid.map(row => [...row]); // Deep copy current grid\n    \n    // Get adjacent cells for formula evaluation\n    const adjacentCells = getAdjacentCells(grid, row, col);\n    \n    if (formula) {\n      // Apply specific formula if selected\n      const shouldTransform = evaluateFormula(\n        formula.condition, \n        grid[row][col], \n        adjacentCells\n      );\n      \n      if (shouldTransform) {\n        // For simplicity, assuming result is always a MatterType\n        newGrid[row][col] = formula.result as MatterType;\n        setGrid(newGrid);\n      }\n    } else {\n      // Auto-apply first applicable formula based on game rules\n      // Here we could implement game-specific rules from the project\n      const waterToEarth = grid[row][col] === MatterType.WATER && \n        adjacentCells.filter(cell => cell === MatterType.FIRE).length >= 2;\n      \n      const earthToAir = grid[row][col] === MatterType.EARTH && \n        adjacentCells.includes(MatterType.WATER) &&\n        adjacentCells.includes(MatterType.AETHER);\n      \n      const fireToWater = grid[row][col] === MatterType.FIRE &&\n        adjacentCells.every(cell => cell === MatterType.VOID);\n      \n      const airToAether = grid[row][col] === MatterType.AIR &&\n        adjacentCells.filter(cell => cell !== MatterType.VOID).length >= 3;\n      \n      const aetherToFire = grid[row][col] === MatterType.AETHER &&\n        adjacentCells.includes(MatterType.AIR);\n      \n      if (waterToEarth) {\n        newGrid[row][col] = MatterType.EARTH;\n        setGrid(newGrid);\n      } else if (earthToAir) {\n        newGrid[row][col] = MatterType.AIR;\n        setGrid(newGrid);\n      } else if (fireToWater) {\n        newGrid[row][col] = MatterType.WATER;\n        setGrid(newGrid);\n      } else if (airToAether) {\n        newGrid[row][col] = MatterType.AETHER;\n        setGrid(newGrid);\n      } else if (aetherToFire) {\n        newGrid[row][col] = MatterType.FIRE;\n        setGrid(newGrid);\n      }\n    }\n  }, [gameState, setGrid]);\n  \n  const undoLastMove = useCallback(() => {\n    setGameState(prevState => {\n      if (prevState.history.length <= 1) return prevState;\n      \n      const newHistory = [...prevState.history];\n      newHistory.pop(); // Remove current state\n      \n      return {\n        grid: newHistory[newHistory.length - 1].map(row => [...row]), // Deep copy last state\n        history: newHistory,\n        moves: prevState.moves - 1\n      };\n    });\n  }, []);\n  \n  const resetGrid = useCallback(() => {\n    setGameState({\n      grid: initialGrid.map(row => [...row]), // Deep copy initial grid\n      history: [initialGrid.map(row => [...row])], // Reset history with only initial state\n      moves: 0\n    });\n  }, [initialGrid]);\n  \n  // Check if puzzle is solved by comparing with target grid\n  const isSolved = useCallback(() => {\n    if (!targetGrid) return false;\n    \n    const { grid } = gameState;\n    \n    // Compare current grid with target grid\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (grid[i][j] !== targetGrid[i][j]) {\n          return false;\n        }\n      }\n    }\n    \n    return true;\n  }, [gameState, targetGrid]);\n  \n  return {\n    grid: gameState.grid,\n    moves: gameState.moves,\n    setGrid,\n    applyMatterTransformation,\n    undoLastMove,\n    resetGrid,\n    isSolved: isSolved()\n  };\n};\n"],"version":3}