8702803d0666b76ff77e6d878585ff35
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.countMatterType = exports.areGridsEqual = exports.copyGrid = exports.getAdjacentCells = void 0;
// src/utils/gridUtils.ts
const GameTypes_1 = require("../types/GameTypes");
/**
 * Get adjacent cell matter types for a specific cell
 * @param grid The current game grid
 * @param row The row of the target cell
 * @param col The column of the target cell
 * @returns Array of adjacent matter types
 */
const getAdjacentCells = (grid, row, col) => {
    const adjacentCells = [];
    const directions = [
        [-1, 0], // Up
        [1, 0], // Down
        [0, -1], // Left
        [0, 1], // Right
        [-1, -1], // Up-Left
        [-1, 1], // Up-Right
        [1, -1], // Down-Left
        [1, 1] // Down-Right
    ];
    for (const [dx, dy] of directions) {
        const newRow = row + dx;
        const newCol = col + dy;
        // Check if the adjacent cell is within bounds
        if (newRow >= 0 &&
            newRow < grid.length &&
            newCol >= 0 &&
            newCol < grid[0].length) {
            adjacentCells.push(grid[newRow][newCol]);
        }
        else {
            // For cells outside the grid, consider them as VOID
            adjacentCells.push(GameTypes_1.MatterType.VOID);
        }
    }
    return adjacentCells;
};
exports.getAdjacentCells = getAdjacentCells;
/**
 * Create a deep copy of a grid
 * @param grid The grid to copy
 * @returns A new grid with the same values
 */
const copyGrid = (grid) => {
    return grid.map(row => [...row]);
};
exports.copyGrid = copyGrid;
/**
 * Check if two grids are equal
 * @param gridA First grid
 * @param gridB Second grid
 * @returns True if grids are equal, false otherwise
 */
const areGridsEqual = (gridA, gridB) => {
    if (gridA.length !== gridB.length || gridA[0].length !== gridB[0].length) {
        return false;
    }
    for (let i = 0; i < gridA.length; i++) {
        for (let j = 0; j < gridA[i].length; j++) {
            if (gridA[i][j] !== gridB[i][j]) {
                return false;
            }
        }
    }
    return true;
};
exports.areGridsEqual = areGridsEqual;
/**
 * Count the number of specific matter type in a grid
 * @param grid The game grid
 * @param type Matter type to count
 * @returns Count of the specified matter type
 */
const countMatterType = (grid, type) => {
    let count = 0;
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[i].length; j++) {
            if (grid[i][j] === type) {
                count++;
            }
        }
    }
    return count;
};
exports.countMatterType = countMatterType;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3NheWFudGFucGFsMTAwL0Rlc2t0b3AvTXVtdS0tb25jaGFpbi1wdXp6bGUtZ2FtZS9mcm9udGVuZC9zcmMvdXRpbHMvZ3JpZFV0aWxzLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHlCQUF5QjtBQUN6QixrREFBZ0Q7QUFFaEQ7Ozs7OztHQU1HO0FBQ0ksTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLElBQW9CLEVBQUUsR0FBVyxFQUFFLEdBQVcsRUFBZ0IsRUFBRTtJQUMvRixNQUFNLGFBQWEsR0FBaUIsRUFBRSxDQUFDO0lBQ3ZDLE1BQU0sVUFBVSxHQUFHO1FBQ2pCLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUcsS0FBSztRQUNmLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFJLE9BQU87UUFDakIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRyxPQUFPO1FBQ2pCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFJLFFBQVE7UUFDbEIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVU7UUFDcEIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRyxXQUFXO1FBQ3JCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUcsWUFBWTtRQUN0QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBSSxhQUFhO0tBQ3hCLENBQUM7SUFFRixLQUFLLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLElBQUksVUFBVSxFQUFFLENBQUM7UUFDbEMsTUFBTSxNQUFNLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUN4QixNQUFNLE1BQU0sR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBRXhCLDhDQUE4QztRQUM5QyxJQUNFLE1BQU0sSUFBSSxDQUFDO1lBQ1gsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNO1lBQ3BCLE1BQU0sSUFBSSxDQUFDO1lBQ1gsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQ3ZCLENBQUM7WUFDRCxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzNDLENBQUM7YUFBTSxDQUFDO1lBQ04sb0RBQW9EO1lBQ3BELGFBQWEsQ0FBQyxJQUFJLENBQUMsc0JBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QyxDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sYUFBYSxDQUFDO0FBQ3ZCLENBQUMsQ0FBQztBQWhDVyxRQUFBLGdCQUFnQixvQkFnQzNCO0FBRUY7Ozs7R0FJRztBQUNJLE1BQU0sUUFBUSxHQUFHLENBQUMsSUFBb0IsRUFBa0IsRUFBRTtJQUMvRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBQUM7QUFGVyxRQUFBLFFBQVEsWUFFbkI7QUFFRjs7Ozs7R0FLRztBQUNJLE1BQU0sYUFBYSxHQUFHLENBQUMsS0FBcUIsRUFBRSxLQUFxQixFQUFXLEVBQUU7SUFDckYsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLEtBQUssQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDekUsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUN0QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3pDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNoQyxPQUFPLEtBQUssQ0FBQztZQUNmLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyxDQUFDO0FBZFcsUUFBQSxhQUFhLGlCQWN4QjtBQUVGOzs7OztHQUtHO0FBQ0ksTUFBTSxlQUFlLEdBQUcsQ0FBQyxJQUFvQixFQUFFLElBQWdCLEVBQVUsRUFBRTtJQUNoRixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFFZCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ3JDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDeEMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7Z0JBQ3hCLEtBQUssRUFBRSxDQUFDO1lBQ1YsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUM7QUFaVyxRQUFBLGVBQWUsbUJBWTFCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXlhbnRhbnBhbDEwMC9EZXNrdG9wL011bXUtLW9uY2hhaW4tcHV6emxlLWdhbWUvZnJvbnRlbmQvc3JjL3V0aWxzL2dyaWRVdGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZ3JpZFV0aWxzLnRzXG5pbXBvcnQgeyBNYXR0ZXJUeXBlIH0gZnJvbSAnLi4vdHlwZXMvR2FtZVR5cGVzJztcblxuLyoqXG4gKiBHZXQgYWRqYWNlbnQgY2VsbCBtYXR0ZXIgdHlwZXMgZm9yIGEgc3BlY2lmaWMgY2VsbFxuICogQHBhcmFtIGdyaWQgVGhlIGN1cnJlbnQgZ2FtZSBncmlkXG4gKiBAcGFyYW0gcm93IFRoZSByb3cgb2YgdGhlIHRhcmdldCBjZWxsXG4gKiBAcGFyYW0gY29sIFRoZSBjb2x1bW4gb2YgdGhlIHRhcmdldCBjZWxsXG4gKiBAcmV0dXJucyBBcnJheSBvZiBhZGphY2VudCBtYXR0ZXIgdHlwZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFkamFjZW50Q2VsbHMgPSAoZ3JpZDogTWF0dGVyVHlwZVtdW10sIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IE1hdHRlclR5cGVbXSA9PiB7XG4gIGNvbnN0IGFkamFjZW50Q2VsbHM6IE1hdHRlclR5cGVbXSA9IFtdO1xuICBjb25zdCBkaXJlY3Rpb25zID0gW1xuICAgIFstMSwgMF0sICAvLyBVcFxuICAgIFsxLCAwXSwgICAvLyBEb3duXG4gICAgWzAsIC0xXSwgIC8vIExlZnRcbiAgICBbMCwgMV0sICAgLy8gUmlnaHRcbiAgICBbLTEsIC0xXSwgLy8gVXAtTGVmdFxuICAgIFstMSwgMV0sICAvLyBVcC1SaWdodFxuICAgIFsxLCAtMV0sICAvLyBEb3duLUxlZnRcbiAgICBbMSwgMV0gICAgLy8gRG93bi1SaWdodFxuICBdO1xuICBcbiAgZm9yIChjb25zdCBbZHgsIGR5XSBvZiBkaXJlY3Rpb25zKSB7XG4gICAgY29uc3QgbmV3Um93ID0gcm93ICsgZHg7XG4gICAgY29uc3QgbmV3Q29sID0gY29sICsgZHk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGFkamFjZW50IGNlbGwgaXMgd2l0aGluIGJvdW5kc1xuICAgIGlmIChcbiAgICAgIG5ld1JvdyA+PSAwICYmIFxuICAgICAgbmV3Um93IDwgZ3JpZC5sZW5ndGggJiYgXG4gICAgICBuZXdDb2wgPj0gMCAmJiBcbiAgICAgIG5ld0NvbCA8IGdyaWRbMF0ubGVuZ3RoXG4gICAgKSB7XG4gICAgICBhZGphY2VudENlbGxzLnB1c2goZ3JpZFtuZXdSb3ddW25ld0NvbF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgY2VsbHMgb3V0c2lkZSB0aGUgZ3JpZCwgY29uc2lkZXIgdGhlbSBhcyBWT0lEXG4gICAgICBhZGphY2VudENlbGxzLnB1c2goTWF0dGVyVHlwZS5WT0lEKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBhZGphY2VudENlbGxzO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgYSBncmlkXG4gKiBAcGFyYW0gZ3JpZCBUaGUgZ3JpZCB0byBjb3B5XG4gKiBAcmV0dXJucyBBIG5ldyBncmlkIHdpdGggdGhlIHNhbWUgdmFsdWVzXG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5R3JpZCA9IChncmlkOiBNYXR0ZXJUeXBlW11bXSk6IE1hdHRlclR5cGVbXVtdID0+IHtcbiAgcmV0dXJuIGdyaWQubWFwKHJvdyA9PiBbLi4ucm93XSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byBncmlkcyBhcmUgZXF1YWxcbiAqIEBwYXJhbSBncmlkQSBGaXJzdCBncmlkXG4gKiBAcGFyYW0gZ3JpZEIgU2Vjb25kIGdyaWRcbiAqIEByZXR1cm5zIFRydWUgaWYgZ3JpZHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGFyZUdyaWRzRXF1YWwgPSAoZ3JpZEE6IE1hdHRlclR5cGVbXVtdLCBncmlkQjogTWF0dGVyVHlwZVtdW10pOiBib29sZWFuID0+IHtcbiAgaWYgKGdyaWRBLmxlbmd0aCAhPT0gZ3JpZEIubGVuZ3RoIHx8IGdyaWRBWzBdLmxlbmd0aCAhPT0gZ3JpZEJbMF0ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWRBLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkQVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGdyaWRBW2ldW2pdICE9PSBncmlkQltpXVtqXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBzcGVjaWZpYyBtYXR0ZXIgdHlwZSBpbiBhIGdyaWRcbiAqIEBwYXJhbSBncmlkIFRoZSBnYW1lIGdyaWRcbiAqIEBwYXJhbSB0eXBlIE1hdHRlciB0eXBlIHRvIGNvdW50XG4gKiBAcmV0dXJucyBDb3VudCBvZiB0aGUgc3BlY2lmaWVkIG1hdHRlciB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCBjb3VudE1hdHRlclR5cGUgPSAoZ3JpZDogTWF0dGVyVHlwZVtdW10sIHR5cGU6IE1hdHRlclR5cGUpOiBudW1iZXIgPT4ge1xuICBsZXQgY291bnQgPSAwO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoZ3JpZFtpXVtqXSA9PT0gdHlwZSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGNvdW50O1xufTtcbiJdLCJ2ZXJzaW9uIjozfQ==